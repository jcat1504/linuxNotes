## Fundamentals of System Design

## SYSTEM DESIGN PRINCIPLES 
**How do we architect a system that supports the functionality and requirements of system in the best way possible?**
- Scalability: Handle additional load and will operate efficiently
- Reliability: Perform function as expected, tolerate user mistakes, good for required use case, prevents unauthorized access/abuse
- Availability: perform its functionality(uptime/total time). Availability does not imply reliability 
- Efficiency: Perform functionality quickly. Latency, response time, bandwidth
- Maintainability: easy to operate smoothly, simple to understand, easy to modify for cases

**TRADEOFFS**: Helpful to understand how each component, algorithms, and architectural designs work.
  - Works independently 
  - Compares to other tools that perform similarily 
 
 ## LOAD BALANCERS 
 - Type of server that distributes incoming web traffic across multiple backend servers
  - Allow applications to scale up or down with demand, achieve higher availability and efficiently utilize server capacity 
  - Horizontal scaling: Add more servers to the system 
    - When one or more servers can be used to serve a request, it becomes necessary to decide which server to send request to
- Good load balancer will efficiently distribute incoming traffic to maximize the systems capacity utilization and minimize queueing time

** Can distribute traffic**:
- Round Robin: servers designed in repeating sequence, so that next server assigned is guaranteed to be least recently used 
- Least Connections: Assigns the server currently handling the fewest number of requests 
- Consistent Hashing: Similar to database sharding, server can be assigned consistently based on IP address or URL
- engineers don't implement load balancers, they use industry standard reverse proxy

**WHEN TO USE LOAD BALANCERS**: When you think the system you're designing would benefit from increased capacity/redundency 
- Advantages: 
  - Scalability: easy to scale up/down by adding/removing servers
  - Reliability: Provide redundancy + minimize downtime by automatically detaching + replacing unhealthy servers
- Considerations: 
  - Bottlenecks: can be single point of failure 
  - User session: some user requests can be served from different backends unless load balancer is configurered otherwise 
  - Longer deploys: deploying ner server versions can take longer and require more machines
 
 ###CACHE
 - Data storage technique that plays a big role in designing scalable internet applications. Stores and retrieves data quickly for future use, 
 enabling faster response times and decreasing loads for other parts of system
 - reduce repeated calculations database queries or requests to other services serving more traffic volume
 HOW IT WORKS:
 - In memory application cache
 - distributed in-memory cache
 - database cache
 - file system cache
 
- Why not cache everything? well there are costs and accuracy to consider. 
Caching policy: helps the cache free up space for the most relevant data that will be needed in the future
  -FIFO
  - Least recently used(LRU)
  - Least frequently used(LFU)
 
 
 ##CONTENT DELIVERY NETWORKS(CDN)
 - a modern and popular solution for minimizing request latency when fetching static assets from a server. An ideal CDN is compoased of a group of servers that are 
 spread out globally, so that no matter how you are from your origin server, there is always a CDN server closeby.
 -so instead of fetching static files from origin server, users can fetch cached copies from cdn more quickly
 
**HOW DO CDNS WORK?** - Push and Pull CDNS
- Push: responsibility of engineers to push new/updated files to the cdn, which would then propagate them to all of the cdn server caches
- Pull : the server cache is lazily updated: when a user sends a static asset request to the cdn server and doesn't have it, it'll fetch the asset from the origin
populate its cache with asset then send asset to the user.

##SQL VS NOSQL
SQL:
- Relationships: relational databases, allows easy querying on relationships between data among multiple tables. They are defined using primary and foreign key columns.
Table relationships are important for organizing and structuring a lot of different data
-Powerful for fetching data
- Structured Data: data is structured using schemas that define the columns and tables in a database. 
- Acid: (Atomicity, Consistency, Isolation, Durability) compliant, and they ensure that by supporting transactions. 
*CONS*
-Take up more time to set up compared to nosql database. they are not effective for storying and querying unstructured data
- Difficult to scale horizontally. 

NoSQL:
- do not support table relationships and data usually stored in documents or as key-value pairs. so it is a bit more flexible and simpler to set up
- without table relationships, nosql database can be sharded across different data stores, allowing for distributed databases. this makes horizontal scaling much easier
and very large amounts of data can be stored without having to purchase a single, expensive server. hashing and consistent hashing are very important techniques
for determining which shard(s) to route application queries to. 

